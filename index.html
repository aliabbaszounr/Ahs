
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signal X</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Orbitron:wght@500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js"></script>

    <style>
        :root {
            --primary-red: #E12A34; /* Dominant Red from image */
            --background-light: #F5F5F5; /* Light grey background */
            --card-light-bg: #FFFFFF; /* White for cards */
            --text-dark: #333333; /* Dark text for general info */
            --text-light: #666666; /* Lighter text for labels */
            --text-red: #E12A34; /* Red for specific text */
            --border-color: #E0E0E0; /* Light border/divider color */
            --win-icon-color: #4CAF50; /* Green for checkmark */
            --loss-icon-color: #F44336; /* Red for cross */
            --tip-button-bg: #2C3E50; /* Dark blue for tip button */
            --tip-button-text: #FFFFFF; /* White text for tip button */
            --odds-bg: #F44336; /* Red for the odds circle */
            --odds-text: #FFFFFF; /* White text for odds */

            /* Colors for the animated heading */
            --color1: #FF0000;
            --color2: #FF7F00;
            --color3: #FFFF00;
            --color4: #00FF00;
            --color5: #0000FF;
            --color6: #4B0082;
            --color7: #9400D3;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background-light);
            margin: 0;
            padding-bottom: 80px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--text-dark);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Top Header */
        .app-header {
            width: 100%;
            max-width: 420px;
            background: linear-gradient(135deg, var(--primary-red), #C2222A);
            color: white;
            padding: 15px 10px;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        .app-header .back-arrow {
            font-size: 28px;
            color: white;
            margin-right: 15px;
            text-decoration: none;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .app-header .back-arrow:active {
            transform: scale(0.9);
        }

        .app-header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            margin: 0;
            flex-grow: 1;
            text-align: center;
            transform: translateX(0);
            transition: transform 0.3s ease;
            background: linear-gradient(90deg, var(--color1), var(--color2), var(--color3), var(--color4), var(--color5), var(--color6), var(--color7));
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: multicolor-text 10s linear infinite;
        }

        .app-header.history-visible h1 {
            transform: translateX(0); /* Removed translation, back arrow handles space */
        }

        @keyframes multicolor-text {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }


        #mainApp {
            width: 100%;
            max-width: 420px;
            padding: 15px;
            box-sizing: border-box;
            flex-grow: 1;
        }

        #homeSection, #historySection {
            display: block;
        }
        #historySection {
            display: none;
        }

        .card {
            background-color: var(--card-light-bg);
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
            padding: 20px;
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border-color);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            font-size: 20px;
            font-weight: 700;
            margin: 0 0 18px 0;
            color: var(--text-dark);
            text-align: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 12px;
        }

        .card-section {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .card-section:last-child {
            margin-bottom: 0;
        }

        .card-label {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-light);
            width: 120px;
            flex-shrink: 0;
        }

        .card-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
            flex-grow: 1;
        }

        .card-value.primary {
            color: var(--text-red);
            font-weight: 700;
        }

        .tip-button {
            background-color: var(--tip-button-bg);
            color: var(--tip-button-text);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            display: inline-block;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .tip-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .odds-circle {
            background-color: var(--odds-bg);
            color: var(--odds-text);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            font-weight: 700;
            margin-left: auto;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .win-icon, .loss-icon {
            font-size: 22px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .win-icon { color: var(--win-icon-color); }
        .loss-icon { color: var(--loss-icon-color); }

        .date-section {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-size: 13px;
            color: var(--text-light);
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 10px;
        }

        .date-section img {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            filter: grayscale(80%);
            opacity: 0.8;
        }

        .prediction-summary-card {
            background-color: var(--card-light-bg);
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .prediction-summary-card p {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            margin: 10px 0;
            color: var(--text-dark);
            border-bottom: 1px dashed rgba(0,0,0,0.05);
            padding-bottom: 5px;
        }
        .prediction-summary-card p:last-of-type {
            border-bottom: none;
            padding-bottom: 0;
        }
        .prediction-summary-card p span:last-child {
            color: var(--text-red);
            font-weight: 700;
            font-family: 'Share Tech Mono', monospace;
        }

        #latestResultsDisplay {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            padding-top: 15px;
            margin-top: 15px;
            border-top: 2px dashed var(--border-color);
        }

        #latestResultsDisplay span {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 12px;
            border-radius: 20px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            min-width: 55px;
            box-sizing: border-box;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }
        #predictionValue {
            font-size: 32px;
            font-weight: 900;
            color: var(--primary-red);
            animation: pulseRed 1.8s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }
        #currentPeriod {
            font-family: 'Share Tech Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }

        @keyframes pulseRed {
            from { text-shadow: 0 0 8px rgba(225, 42, 52, 0.6), 0 0 15px rgba(225, 42, 52, 0.3); }
            to { text-shadow: 0 0 15px rgba(225, 42, 52, 0.8), 0 0 25px rgba(225, 42, 52, 0.5); }
        }

        /* Telegram Button (for main link) */
        .telegram-button {
            display: block;
            width: calc(100% - 30px);
            max-width: 390px;
            background: linear-gradient(45deg, #0088CC, #005B8C);
            color: white;
            padding: 18px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            text-decoration: none;
            margin: 25px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            letter-spacing: 0.5px;
        }
        .telegram-button:hover {
            background: linear-gradient(45deg, #005B8C, #0088CC);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        .telegram-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        /* Community & Gifts Card Styling */
        .community-buttons { text-align: center; margin-bottom: 25px; }
        .link-button {
            display: inline-block; margin: 8px;
            background: #0D6EFD;
            color: white; padding: 12px 18px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 15px;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .link-button.whatsapp { background: #25D366; }
        .link-button.permanent { background: #9B59B6; }
        .link-button.game { background: linear-gradient(45deg, #20B2AA, #1A928A); }


        .link-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .link-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

         /* Styling for the two gift code sections */
        .gift-section {
             margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px dashed var(--border-color);
        }
        .gift-section:last-child {
             border-bottom: none;
             margin-bottom: 0;
             padding-bottom: 0;
        }
        .gift-section h3 {
            font-size: 16px;
            font-weight: 700;
            margin: 0 0 10px 0;
            color: var(--text-dark);
        }


        .gift-box {
            background: #f0f0f0;
            padding: 10px; /* Slightly less padding */
            margin-top: 5px; /* Less margin */
            border-radius: 8px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 16px; /* Slightly smaller font */
            font-weight: bold;
            text-align: center;
            border: 2px dashed #d0d0d0;
            color: var(--text-dark);
            word-break: break-all;
            min-height: 40px; /* Ensure box has some height even if empty */
            display: flex; /* Center content vertically */
            align-items: center;
            justify-content: center;
        }
        #copyCodeBtn {
            margin-top: 15px;
            padding: 12px 15px;
            width: 100%;
            background: linear-gradient(45deg, #0D6EFD, #0A5EDF);
            color: white; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold;
            font-size: 16px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }
        #copyCodeBtn:hover {
            background: linear-gradient(45deg, #0A5EDF, #0D6EFD);
            transform: translateY(-1px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }
        #copyCodeBtn:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        /* Announcement Popup Overlay */
        #announcementPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Dark semi-transparent background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Above everything else */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            padding: 15px; /* Add padding to prevent content from touching edges on small screens */
            box-sizing: border-box;
        }

        #announcementPopup.show {
            opacity: 1;
            visibility: visible;
        }

        /* Announcement Popup Content Container */
        .popup-content {
            background: linear-gradient(135deg, #2c3e50, #1a2a3a); /* Default dark gradient */
            color: white;
            padding: 25px; /* More padding */
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5); /* Deeper shadow */
            max-width: 380px; /* Max width for content */
            width: 100%; /* Responsive width */
            position: relative; /* For close button positioning */
            transform: scale(0.9);
            transition: transform 0.3s ease;
            max-height: 90vh; /* Limit height */
            overflow-y: auto; /* Add scroll if content overflows */
             box-sizing: border-box;
        }

        #announcementPopup.show .popup-content {
            transform: scale(1); /* Pop in effect */
        }

        /* Area where dynamic announcement content is placed */
        #dynamicAnnouncementContent {
             /* Basic styling for injected content */
             text-align: left; /* Allow injected HTML to define its own text alignment */
        }

        /* --- Styling for Text Announcement content when injected --- */
        #dynamicAnnouncementContent h3 {
            margin-top: 0;
            font-size: 22px; /* Larger heading */
            font-weight: 700;
            margin-bottom: 15px;
            letter-spacing: 0.5px;
            text-align: center; /* Keep heading centered by default */
        }
        #dynamicAnnouncementContent p {
            font-size: 16px; /* Larger body text */
            line-height: 1.6;
            margin-bottom: 20px; /* More space before button */
            opacity: 0.9;
            word-wrap: break-word; /* Ensure text wraps */
             text-align: center; /* Keep paragraph centered by default */
        }

        /* Style for links inside text announcements (using p a) */
        #dynamicAnnouncementContent p a {
            color: inherit; /* Inherit text color */
            text-decoration: underline;
            font-weight: 600;
            word-break: break-all; /* Break long URLs */
        }

         /* --- Styling for HTML Announcement content when injected --- */
         /* The HTML content itself can contain any valid HTML, */
         /* but you might want some default styles */
         #dynamicAnnouncementContent > *:first-child { margin-top: 0; } /* Remove top margin on first child */
         #dynamicAnnouncementContent > *:last-child { margin-bottom: 0; } /* Remove bottom margin on last child */
         #dynamicAnnouncementContent img { max-width: 100%; height: auto; } /* Make images responsive */


        /* Close Button for Popup */
        #closePopupBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.2); /* Semi-transparent white */
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 2001; /* Ensure close button is above content */
        }
        #closePopupBtn:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }
        #closePopupBtn:active {
            transform: scale(0.9);
        }


        /* Bottom Nav Bar */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 420px;
            background-color: #FFFFFF;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.15);
            padding: 12px 0;
            display: flex;
            justify-content: space-around;
            z-index: 1000;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 13px;
            color: var(--text-light);
            text-decoration: none;
            flex: 1;
            cursor: pointer;
            padding: 5px 0;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .nav-item:active {
            transform: translateY(1px);
        }
        .nav-item.active {
            color: var(--primary-red);
            font-weight: 700;
        }
        .nav-item img {
            width: 28px;
            height: 28px;
            margin-bottom: 5px;
            filter: grayscale(100%);
            opacity: 0.6;
            transition: filter 0.2s ease, opacity 0.2s ease;
        }
        .nav-item.active img {
            filter: none;
            opacity: 1;
        }

        /* Mobile adjustments */
        @media (max-width: 450px) {
            .app-header h1 {
                font-size: 24px;
            }
            .card {
                padding: 15px;
            }
            .card-label {
                width: 100px;
                font-size: 14px;
            }
            .card-value {
                font-size: 15px;
            }
            .tip-button {
                font-size: 12px;
                padding: 6px 10px;
            }
            .odds-circle {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            .win-icon, .loss-icon {
                font-size: 20px;
            }
            .date-section {
                font-size: 12px;
            }
            .prediction-summary-card h2 {
                font-size: 18px;
            }
            .prediction-summary-card p {
                font-size: 15px;
            }
            #latestResultsDisplay span {
                font-size: 12px;
                padding: 5px 10px;
                min-width: 50px;
            }
            #predictionValue {
                font-size: 28px;
            }
            .telegram-button {
                font-size: 16px;
                padding: 15px 18px;
            }
            .link-button {
                padding: 10px 15px;
                font-size: 14px;
                margin: 6px;
            }
            #copyCodeBtn {
                padding: 10px 12px;
                font-size: 15px;
            }
            .popup-content h3 {
                font-size: 18px;
            }
            .popup-content p {
                font-size: 14px;
            }
            .nav-item img {
                width: 24px;
                height: 24px;
            }
            .nav-item {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="app-header" id="appHeader">
        <a href="#" class="back-arrow" id="backArrow" style="display:none;"></a>
        <h1 id="headerTitle">Signal X</h1>
    </div>

    <div id="mainApp">
        <!-- The old announcement card is removed -->

        <div id="homeSection">
            <div id="stats" class="card prediction-summary-card">
                <h2>Performance Overview</h2>
                <p>Total Cycles: <span><span id="totalCycles">0</span></span></p>
                <p>Correct Predictions: <span><span id="totalWins">0</span></span></p>
                <p>Incorrect Predictions: <span><span id="totalLosses">0</span></span></p>
                <p>Accuracy Rate: <span><span id="accuracy">0%</span></span></p>
            </div>

            <div id="currentPrediction" class="card prediction-summary-card">
                <h2>Next Prediction</h2>
                <div class="card-section">
                    <span class="card-label">Trend from last 10:</span>
                    <div id="latestResultsDisplay">
                        <!-- Trend spans will be injected here -->
                    </div>
                </div>
                <div class="card-section">
                    <span class="card-label">Current Cycle:</span>
                    <span class="card-value" id="currentPeriod">-</span>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <div class="card-label" style="width: auto; display: block; margin-bottom: 5px;">Predicted Outcome:</div>
                    <div class="prediction-value" id="predictionValue">-</div>
                </div>
            </div>

            <!-- Community & Gifts Card -->
            <div class="card">
                <h2>Community & Gifts</h2>
                 <!-- Game Link Display -->
                <div class="card-section" style="margin-bottom: 15px;">
                    <span class="card-label" style="width: auto; flex-grow: 0; margin-right: 10px;">< Play Game:</span>
                    <a href="#" id="gameLinkDisplay" class="link-button game" target="_blank" style="display:none;">-</a>
                </div>

                <div class="community-buttons">
                    <a id="telegramLink" href="#" class="link-button" target="_blank">Telegram</a>
                    <a id="whatsappLink" href="#" class="link-button whatsapp" style="display:none;" target="_blank">WhatsApp</a>
                    <a id="permanentLinkContainer" href="#" class="link-button permanent" style="display:none;" target="_blank">Permanent Channel</a>
                </div>

                <!-- Gift Code 1 Section -->
                 <div class="gift-section">
                     <h3>Gift Code 1 for <span id="giftSiteName1">-</span></h3>
                     <div class="gift-box" id="giftCodeValue1">-</div>
                 </div>

                 <!-- Gift Code 2 Section -->
                 <div class="gift-section">
                      <h3>Gift Code 2 for <span id="giftSiteName2">-</span></h3>
                     <div class="gift-box" id="giftCodeValue2">-</div>
                 </div>

                <button id="copyCodeBtn">Copy Gift Code 1</button> <!-- Button now explicitly copies Gift Code 1 -->
            </div>

            <a class="telegram-button" href="https://t.me/colourperdiction9778" target="_blank">Join Our Official Channel</a>
        </div>

        <div id="historySection">
             <!-- History cards will be dynamically inserted here -->
        </div>

    </div>

   



    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyAyJTsImWKkkIZ5q7NBOvx3ueVyvnaHeoM",
          authDomain: "signal-x-58b1b.firebaseapp.com",
          databaseURL: "https://signal-x-58b1b-default-rtdb.firebaseio.com",
          projectId: "signal-x-58b1b",
          storageBucket: "signal-x-58b1b.appspot.com",
          messagingSenderId: "970250731953",
          appId: "1:970250731953:web:e3742ba752580a1941bd90",
          measurementId: "G-Z15NY750GR"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();


        let historyData = []; // Stores our app's prediction history
        let lastKnownApiPeriod = null; // To track the last processed period from API

        const homeSection = document.getElementById('homeSection');
        const historySection = document.getElementById('historySection');
        const homeNavButton = document.getElementById('homeNavButton');
        const historyNavButton = document.getElementById('historyNavButton');
        const appHeader = document.getElementById('appHeader');
        const headerTitle = document.getElementById('headerTitle');
        const backArrow = document.getElementById('backArrow');

        // Game Link Display
        const gameLinkDisplay = document.getElementById('gameLinkDisplay');

        // Gift Code Elements (Updated for two)
        const giftSiteName1 = document.getElementById('giftSiteName1');
        const giftCodeValue1 = document.getElementById('giftCodeValue1');
        const giftSiteName2 = document.getElementById('giftSiteName2');
        const giftCodeValue2 = document.getElementById('giftCodeValue2');

        // Announcement Popup elements
        const announcementPopup = document.getElementById('announcementPopup');
        const dynamicAnnouncementContent = document.getElementById('dynamicAnnouncementContent'); // New div to hold content
        const closePopupBtn = document.getElementById('closePopupBtn');


        /**
         * Toggles the display of sections (Home/History) and updates navigation.
         * @param {string} sectionId - The ID of the section to show ('home' or 'history').
         */
        function showSection(sectionId) {
            homeSection.style.display = 'none';
            historySection.style.display = 'none';

            if (sectionId === 'home') {
                homeSection.style.display = 'block';
                homeNavButton.classList.add('active');
                historyNavButton.classList.remove('active');
                headerTitle.innerText = 'Signal X';
                backArrow.style.display = 'none';
                appHeader.classList.remove('history-visible');
            } else if (sectionId === 'history') {
                historySection.style.display = 'block';
                homeNavButton.classList.remove('active');
                historyNavButton.classList.add('active');
                headerTitle.innerText = 'Prediction History';
                backArrow.style.display = 'block';
                appHeader.classList.add('history-visible');
                updateHistoryUI();
            }
        }

        // Event Listeners for navigation buttons
        homeNavButton.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('home');
        });

        historyNavButton.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('history');
        });

        backArrow.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('home');
        });

        // Close popup button event listener
        closePopupBtn.addEventListener('click', () => {
            announcementPopup.classList.remove('show');
        });

        /**
         * Converts plain text with URLs into HTML with clickable links.
         * The full URL will be displayed as the link text.
         * @param {string} text - The input text, possibly containing URLs.
         * @returns {string} HTML string with URLs converted to clickable links.
         */
        function makeUrlsClickable(text) {
            if (!text) return '';
            // Regex to find URLs starting with http or https
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            // Replace found URLs with an anchor tag, using the found URL as both href and text.
            // Added style to inherit color and ensure text break
            return text.replace(urlRegex, '<a href="$&" target="_blank" style="color: inherit; text-decoration: underline; word-break: break-all;">$&</a>');
        }

        /**
         * Sets up Firebase listeners for general UI data like links, announcements, and game link.
         */
        function setupFirebaseUI() {
          const ref = db.ref("appData");
          ref.on("value", snap => {
            const d = snap.val();
            if (!d) {
                // Clear all dynamic data if appData is empty
                document.getElementById("telegramLink").href = "#";
                document.getElementById("whatsappLink").href = "#";
                document.getElementById("whatsappLink").style.display = "none";
                document.getElementById("permanentLinkContainer").href = "#";
                document.getElementById("permanentLinkContainer").style.display = "none";
                giftSiteName1.textContent = "-";
                giftCodeValue1.textContent = "-";
                giftSiteName2.textContent = "-";
                giftCodeValue2.textContent = "-";
                announcementPopup.classList.remove('show'); // Hide popup if no data
                gameLinkDisplay.href = "#";
                gameLinkDisplay.textContent = "-";
                gameLinkDisplay.style.display = "none";
                return;
            }

            // Channel Links
            document.getElementById("telegramLink").href = d.links?.telegram || "#";

            const whatsappLink = document.getElementById("whatsappLink");
            if (d.links?.whatsapp) {
                whatsappLink.href = d.links.whatsapp;
                whatsappLink.style.display = "inline-block";
            } else {
                whatsappLink.style.display = "none";
            }

            const permLink = document.getElementById("permanentLinkContainer");
            if (d.permanentLink?.url) {
                permLink.href = d.permanentLink.url;
                permLink.style.display = "inline-block";
            } else {
                permLink.style.display = "none";
            }

            // Gift Codes (Load both)
            giftSiteName1.textContent = d.giftCode1?.siteName || "-";
            giftCodeValue1.textContent = d.giftCode1?.code || "-";
            giftSiteName2.textContent = d.giftCode2?.siteName || "-";
            giftCodeValue2.textContent = d.giftCode2?.code || "-";

            // Game Link Display Logic
            if (d.gameLink?.name && d.gameLink?.url) {
                gameLinkDisplay.href = d.gameLink.url;
                gameLinkDisplay.textContent = d.gameLink.name;
                gameLinkDisplay.style.display = "inline-block";
            } else {
                gameLinkDisplay.href = "#";
                gameLinkDisplay.textContent = "-";
                gameLinkDisplay.style.display = "none";
            }

            // Announcement Popup Logic (Handles both types)
            const popupContentDiv = announcementPopup.querySelector('.popup-content'); // Get the content div to apply styles

            // Reset styles to default before applying specific announcement styles
            popupContentDiv.style.background = 'linear-gradient(135deg, #2c3e50, #1a2a3a)'; // Default dark gradient
            popupContentDiv.style.color = 'white'; // Default white text

            // Clear previous content
            dynamicAnnouncementContent.innerHTML = '';


            if (d.htmlAnnouncement?.isActive && d.htmlAnnouncement.content) {
                // Show HTML Announcement if active and has content
                dynamicAnnouncementContent.innerHTML = d.htmlAnnouncement.content;
                 announcementPopup.classList.add('show'); // Show the popup

                 // Note: HTML announcement styles (background, color) should be part of the injected HTML itself
                 // or defined via specific CSS rules targeting #dynamicAnnouncementContent descendants
                 // For now, it will inherit the popup-content's default styles unless overridden in the injected HTML.


            } else if (d.announcement?.isActive && (d.announcement.heading || d.announcement.body)) {
                // Show Text Announcement if HTML is not active AND Text is active
                const heading = d.announcement.heading || 'Announcement'; // Default heading if none provided
                const body = d.announcement.body || 'No message provided.';
                dynamicAnnouncementContent.innerHTML = `
                    <h3 id="popupAnnouncementHeading">${heading}</h3>
                    <p id="popupAnnouncementBody">${makeUrlsClickable(body)}</p>
                `;

                // Apply custom colors from admin panel to the popup content container
                if (d.announcement.backgroundColor) {
                    popupContentDiv.style.background = d.announcement.backgroundColor;
                     // Ensure links inside the text announcement also match the text color
                    dynamicAnnouncementContent.querySelectorAll('p a').forEach(link => {
                         link.style.color = d.announcement.textColor || 'white'; // Use specified text color or default white
                     });
                }

                if (d.announcement.textColor) {
                    popupContentDiv.style.color = d.announcement.textColor;
                    dynamicAnnouncementContent.querySelector('#popupAnnouncementHeading').style.color = d.announcement.textColor;
                    dynamicAnnouncementContent.querySelector('#popupAnnouncementBody').style.color = d.announcement.textColor; // Ensure paragraph also gets color
                    // Links inside the text announcement already handled above based on background color presence
                }

                announcementPopup.classList.add('show'); // Show the popup

            } else {
              // Neither announcement is active, hide the popup
              announcementPopup.classList.remove('show');
            }

          }, error => {
              console.error("Firebase data fetch error in user.html:", error);
          });
        }

        // Event listener for copy gift code button
        document.getElementById("copyCodeBtn").addEventListener('click', () => {
          // Copying Gift Code 1
          const code = giftCodeValue1.textContent;
          if (code && code !== '-') {
            navigator.clipboard.writeText(code).then(() => {
              const btn = document.getElementById("copyCodeBtn");
              btn.textContent = "Copied Successfully!";
              btn.style.background = '#4CAF50';
              setTimeout(() => {
                btn.textContent = "Copy Gift Code 1"; // Revert text
                btn.style.background = 'linear-gradient(45deg, #0D6EFD, #0A5EDF)';
              }, 2000);
            }).catch(err => {
              console.error("Failed to copy text (Clipboard API): ", err);
              // Fallback for older browsers
              const textArea = document.createElement("textarea");
              textArea.value = code;
              textArea.style.position = "fixed";
              textArea.style.opacity = 0;
              document.body.appendChild(textArea);
              textArea.focus();
              textArea.select();
              try {
                document.execCommand('copy');
                const btn = document.getElementById("copyCodeBtn");
                btn.textContent = "Copied Successfully!";
                btn.style.background = '#4CAF50';
                setTimeout(() => {
                    btn.textContent = "Copy Gift Code 1"; // Revert text
                    btn.style.background = 'linear-gradient(45deg, #0D6EFD, #0A5EDF)';
                }, 2000);
              } catch (err) {
                console.error("Fallback: Failed to copy text: ", err);
                const btn = document.getElementById("copyCodeBtn");
                btn.textContent = "Copy Failed!";
                btn.style.background = '#F44336';
                setTimeout(() => {
                    btn.textContent = "Copy Gift Code 1"; // Revert text
                    btn.style.background = 'linear-gradient(45deg, #0D6EFD, #0A5EDF)';
                }, 2000);
              } finally {
                 document.body.removeChild(textArea);
              }
            });
          }
        });


        /**
         * Fetches game results from the external API.
         * @returns {Promise<Array<object>|null>} A promise that resolves to an array of game results or null on error.
         */
        async function fetchGameResult() {
            // Using a hardcoded URL for bdg88zf as in the original code
            const apiUrl = "https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList";
            const requestBody = {
                pageSize: 10,
                pageNo: 1,
                typeId: 1, // Assuming typeId 1 is the relevant game
                language: 0, // Assuming language 0 is appropriate
                 // These may need to be dynamic or verified if the API requires fresh values
                random: "4a0522c6ecd8410496260e686be2a57c", 
                signature: "334B5E70A0C9B8918B0B15E517E2069C",
                timestamp: Math.floor(Date.now() / 1000)
            };

            try {
                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

                const data = await response.json();
                if (data?.data?.list && data.data.list.length > 0) {
                    return data.data.list.map(item => ({ period: item.issueNumber, result: item.number }));
                } else {
                    // Handle cases where API returns success but no list data
                    console.warn("API returned success but no result list:", data);
                    return []; // Return empty array instead of null for clarity
                }
            } catch (error) {
                console.error("Error fetching game result:", error);
                return null;
            }
        }

        /**
         * Determines a pattern-based prediction (BIG/SMALL) from recent results.
         * Prioritizes repeating patterns, falls back to dominant trend.
         * @param {Array<object>} results - Array of game results {period, result}.
         * @param {number} lookback - Number of recent results to consider for pattern.
         * @returns {object} An object with `trend` (predicted outcome) and `details` (last 'lookback' trends for display).
         */
        function getPatternBasedPrediction(results, lookback = 10) {
            if (!results || results.length < 3) { // Need at least 3 results for basic pattern or trend
                 const defaultTrend = results && results.length > 0 ? (results[0].result >= 5 ? "BIG" : "SMALL") : "UNKNOWN";
                 const defaultDetails = results ? results.slice(0, lookback).map(item => item.result >= 5 ? "BIG" : "SMALL") : [];
                 return { trend: defaultTrend, details: defaultDetails };
            }

            const recentOutcomes = results.slice(0, lookback).map(item => item.result >= 5 ? "BIG" : "SMALL");

            // Look for repeating patterns from longest possible down to length 1
            for (let patternLength = Math.floor(recentOutcomes.length / 2); patternLength >= 1; patternLength--) {
                const potentialPattern = recentOutcomes.slice(0, patternLength);
                if (potentialPattern.length === 0) continue; // Should not happen with loop condition, but safety

                let isRepeating = true;
                for (let i = patternLength; i < recentOutcomes.length; i++) {
                     // Check if the current element matches the pattern element at the corresponding index (modulo patternLength)
                    if (recentOutcomes[i] !== potentialPattern[i % patternLength]) {
                        isRepeating = false;
                        break;
                    }
                }

                if (isRepeating) {
                     // If a repeating pattern is found, the next prediction is the next element in the pattern sequence
                    const nextIndexInPattern = recentOutcomes.length % patternLength;
                    const prediction = potentialPattern[nextIndexInPattern];
                    // console.log(`Pattern found (length ${patternLength}). Next is ${prediction}.`);
                    return { trend: prediction, details: recentOutcomes };
                }
            }

            // If no repeating pattern is found, fall back to the dominant trend
            // console.log("No repeating pattern found. Using dominant trend.");
            return getDominantTrendPrediction(results, lookback);
        }

        /**
         * Determines the dominant trend (BIG/SMALL) from recent results if no pattern is found.
         * @param {Array<object>} results - Array of game results {period, result}.
         * @param {number} lookback - Number of recent results to consider.
         * @returns {object} An object with `trend` (predicted outcome) and `details` (last 'lookback' trends for display).
         */
        function getDominantTrendPrediction(results, lookback) {
             const recentOutcomes = results ? results.slice(0, lookback).map(item => item.result >= 5 ? "BIG" : "SMALL") : [];
             if (recentOutcomes.length === 0) return { trend: "UNKNOWN", details: [] };

            let bigCount = recentOutcomes.filter(o => o === "BIG").length;
            let smallCount = recentOutcomes.filter(o => o === "SMALL").length;

            let dominant = "UNKNOWN";
            if (bigCount > smallCount) {
                dominant = "BIG";
            } else if (smallCount > bigCount) {
                dominant = "SMALL";
            } else {
                // If counts are equal, predict based on the most recent outcome
                 if (recentOutcomes.length > 0) {
                    dominant = recentOutcomes[0];
                 } else {
                     dominant = "UNKNOWN"; // Should not happen if length > 0 checked above
                 }
            }
            return { trend: dominant, details: recentOutcomes };
        }

        /**
         * Main function to fetch API data, update predictions, and manage history.
         */
        async function updatePredictionAndHistory() {
            const apiResults = await fetchGameResult();

            if (apiResults && apiResults.length > 0) {
                const latestApiResult = apiResults[0];

                const { trend: currentTrendPrediction, details: last10TrendDetails } = getPatternBasedPrediction(apiResults, 10);

                // Update the display of the last 10 trends
                const latestResultsDisplay = document.getElementById("latestResultsDisplay");
                latestResultsDisplay.innerHTML = last10TrendDetails.map(t => `<span style="background-color: ${t === 'BIG' ? 'var(--primary-red)' : 'var(--tip-button-bg)'};">${t}</span>`).join('');


                // Process new period if detected
                // Note: API issueNumber can be large, using BigInt for comparison
                const currentApiPeriodBigInt = BigInt(latestApiResult.period);

                if (lastKnownApiPeriod === null || currentApiPeriodBigInt > BigInt(lastKnownApiPeriod)) {
                    console.log(`New API period detected: ${latestApiResult.period}`);
                    lastKnownApiPeriod = latestApiResult.period; // Update last known period

                    // Find the current pending prediction in our history
                     // Use BigInt for comparison
                    const nextExpectedPeriodBigInt = currentApiPeriodBigInt + 1n;
                    const nextExpectedPeriod = nextExpectedPeriodBigInt.toString();

                    const existingPendingIndex = historyData.findIndex(item => BigInt(item.period) === nextExpectedPeriodBigInt && item.status === "Pending");


                    // If the newly fetched API result matches a pending prediction period, update its status
                    historyData.forEach(item => {
                        if (item.status === "Pending" && BigInt(item.period) === currentApiPeriodBigInt) {
                             const actualOutcome = latestApiResult.result >= 5 ? "BIG" : "SMALL";
                             item.actualResult = latestApiResult.result;
                             item.status = (item.prediction === actualOutcome) ? "WIN" : "LOSS";
                             console.log(`Prediction for period ${item.period} was ${item.prediction}, actual was ${actualOutcome}. Result: ${item.status}`);
                        }
                    });


                    // Now, add a new pending prediction for the NEXT period if one doesn't exist
                     // Check if a pending prediction for the *actual* next period already exists
                    const hasPendingForNextPeriod = historyData.some(item => BigInt(item.period) === nextExpectedPeriodBigInt && item.status === "Pending");

                    if (!hasPendingForNextPeriod) {
                        const predictionForNext = getPatternBasedPrediction(apiResults, 10).trend; // Get prediction for the next period based on the *latest* results
                         console.log(`Adding new pending prediction for period ${nextExpectedPeriod}: ${predictionForNext}`);

                        historyData.unshift({ // Add to the beginning
                            period: nextExpectedPeriod,
                            prediction: predictionForNext,
                            status: "Pending",
                            actualResult: null, // No result yet
                            date: new Date().toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '/') + ' ' + new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false}) // Use device local time
                        });

                        // Update UI for the next prediction immediately
                        document.getElementById("currentPeriod").innerText = nextExpectedPeriod;
                        document.getElementById("predictionValue").innerText = predictionForNext;

                    } else {
                         // If a pending prediction for the next period *does* exist (maybe from a previous run or refresh),
                         // just update the display with its details in case they weren't set correctly
                         const existingPending = historyData.find(item => BigInt(item.period) === nextExpectedPeriodBigInt && item.status === "Pending");
                         if(existingPending) {
                             document.getElementById("currentPeriod").innerText = existingPending.period;
                             document.getElementById("predictionValue").innerText = existingPending.prediction;
                         } else {
                              // Fallback if for some reason we expected one but didn't find it (shouldn't happen)
                             document.getElementById("currentPeriod").innerText = nextExpectedPeriod;
                             document.getElementById("predictionValue").innerText = getPatternBasedPrediction(apiResults, 10).trend;
                         }
                    }

                    // Trim history to keep it manageable
                    historyData = historyData.slice(0, 20); // Keep only the latest 20 predictions

                    // Save history to local storage (optional, but good for persistence between page loads)
                    // localStorage.setItem('predictionHistory', JSON.stringify(historyData)); // Implement localStorage load on init if using this

                } else {
                    // If the API period hasn't changed, just ensure the UI reflects the current pending prediction
                    const nextExpectedPeriodBigInt = currentApiPeriodBigInt + 1n;
                     const nextExpectedPeriod = nextExpectedPeriodBigInt.toString();
                     const currentPending = historyData.find(item => BigInt(item.period) === nextExpectedPeriodBigInt && item.status === "Pending");

                     if (currentPending) {
                        document.getElementById("currentPeriod").innerText = currentPending.period;
                        document.getElementById("predictionValue").innerText = currentPending.prediction;
                     } else {
                         // This case might happen on first load if API is behind or no history exists
                         // Predict for the next period based on current API results
                         document.getElementById("currentPeriod").innerText = nextExpectedPeriod;
                         document.getElementById("predictionValue").innerText = getPatternBasedPrediction(apiResults, 10).trend;
                          // Add this prediction to history as pending if it's not there
                         if (!historyData.some(item => BigInt(item.period) === nextExpectedPeriodBigInt)) {
                              console.log(`Adding pending prediction for ${nextExpectedPeriod} on initial sync.`);
                              historyData.unshift({
                                period: nextExpectedPeriod,
                                prediction: document.getElementById("predictionValue").innerText, // Use displayed prediction
                                status: "Pending",
                                actualResult: null,
                                date: new Date().toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '/') + ' ' + new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false})
                             });
                             historyData = historyData.slice(0, 20);
                         }
                     }
                }

                 // Always update stats and history UI after processing
                updateStats();
                // Only update history UI if it's currently visible
                if (historySection.style.display === 'block') {
                    updateHistoryUI();
                }

            } else {
                 // Handle case where API fetch fails or returns no results
                console.warn("Failed to fetch or process API results.");
                document.getElementById("currentPeriod").innerText = "-";
                document.getElementById("predictionValue").innerText = "Fetching...";
                 latestResultsDisplay.innerHTML = '<span style="background-color: gray;">Loading...</span>';
                 updateStats(); // Update stats even if no new data
                 if (historySection.style.display === 'block') {
                     updateHistoryUI(); // Show whatever history is available
                 }
            }
        }

        /**
         * Updates the performance statistics displayed on the Home section.
         */
        function updateStats() {
            const completedCycles = historyData.filter(item => item.status === "WIN" || item.status === "LOSS");
            const totalWins = completedCycles.filter(item => item.status === "WIN").length;
            const totalLosses = completedCycles.filter(item => item.status === "LOSS").length;
            const totalProcessed = totalWins + totalLosses;

            document.getElementById("totalWins").innerText = totalWins;
            document.getElementById("totalLosses").innerText = totalLosses;
            document.getElementById("totalCycles").innerText = totalProcessed;
            document.getElementById("accuracy").innerText = totalProcessed > 0 ? ((totalWins / totalProcessed) * 100).toFixed(2) + '%' : '0%';
        }

        /**
         * Renders the history data into the history section.
         */
        function updateHistoryUI() {
            const historyDiv = document.getElementById("historySection");
            historyDiv.innerHTML = '';

            if (historyData.length === 0) {
                historyDiv.innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 20px;">No prediction history yet.</p>';
                return;
            }

            // Sort history by period (descending) for display
            const sortedHistory = [...historyData].sort((a, b) => BigInt(b.period) - BigInt(a.period));


            sortedHistory.forEach(item => {
                const historyItemDiv = document.createElement('div');
                historyItemDiv.classList.add('card');

                let outcomeIcon = '';
                if (item.status === "WIN") {
                    outcomeIcon = '<img src="https://img.icons8.com/material-outlined/24/4CAF50/checkmark--v1.png" alt="Win" class="win-icon"/>';
                } else if (item.status === "LOSS") {
                    outcomeIcon = '<img src="https://img.icons8.com/material-outlined/24/F44336/multiply.png" alt="Loss" class="loss-icon"/>';
                } else if (item.status === "Pending") {
                     outcomeIcon = ''; // No icon for pending
                }

                historyItemDiv.innerHTML = `
                    <div class="card-section">
                        <span class="card-label primary">Cycle</span>
                        <span class="card-value primary">${item.period}</span>
                    </div>
                    <div class="card-section">
                        <span class="card-label">Prediction</span>
                        <span class="card-value">${item.prediction} ${outcomeIcon}</span>
                        <div class="odds-circle" style="background-color: ${item.actualResult !== null ? (item.actualResult >= 5 ? 'var(--primary-red)' : 'var(--tip-button-bg)') : 'var(--odds-bg)'};">${item.actualResult !== null ? item.actualResult : '?'}</div>
                    </div>
                    <div class="card-section">
                        <span class="card-label">Outcome</span>
                        <span class="card-value">
                            <span class="tip-button" style="background-color: ${item.status === 'WIN' ? 'var(--win-icon-color)' : (item.status === 'LOSS' ? 'var(--loss-icon-color)' : 'var(--tip-button-bg)')};">${item.status}</span>
                        </span>
                    </div>
                    ${item.date ? `<div class="date-section"><img src="https://img.icons8.com/ios-glyphs/30/666666/calendar--v1.png" alt="Calendar Icon"><span>${item.date}</span></div>` : ''}
                `;
                historyDiv.appendChild(historyItemDiv);
            });
        }

        // Initial setup and start of the real-time updates
        document.addEventListener("DOMContentLoaded", () => {
            // Load history from local storage on start (optional)
            // const savedHistory = localStorage.getItem('predictionHistory');
            // if (savedHistory) {
            //     historyData = JSON.parse(savedHistory);
            //     // Ensure period is BigInt if needed for logic, or handle parsing string BigInts
            // }

            showSection('home'); // Start on the Home section
            setupFirebaseUI(); // Set up Firebase listeners for UI data

            // Fetch API and update prediction/history initially
            updatePredictionAndHistory();
            // Set interval for fetching API and updating prediction/history
            setInterval(updatePredictionAndHistory, 5000); // Fetch every 5 seconds
        });
    </script>
</body>
</html>
